/**
 * transcriptExtractor.js
 * YouTube動画から字幕（トランスクリプト）を抽出するモジュール
 * 
 * Firebase Functionsの一部として動作し、YouTube APIを使用して
 * 動画のトランスクリプトを取得・整形する
 */

const functions = require('firebase-functions');
const { google } = require('googleapis');
const axios = require('axios');
const admin = require('firebase-admin');
const db = admin.firestore();

// YouTube Data API v3 クライアントの初期化
const youtube = google.youtube({
  version: 'v3',
  auth: functions.config().youtube.api_key
});

/**
 * 動画IDから字幕トラックのリストを取得
 * @param {string} videoId YouTube動画ID
 * @returns {Promise<Array>} 利用可能な字幕トラックのリスト
 */
async function getCaptionTracks(videoId) {
  try {
    const response = await youtube.captions.list({
      part: 'snippet',
      videoId: videoId
    });

    return response.data.items || [];
  } catch (error) {
    functions.logger.error('字幕トラック取得エラー:', error);
    return [];
  }
}

/**
 * 字幕トラックのコンテンツを取得
 * @param {string} captionId 字幕トラックID
 * @returns {Promise<string>} 字幕テキスト
 */
async function getCaptionContent(captionId) {
  try {
    const response = await youtube.captions.download({
      id: captionId,
      tfmt: 'srt'
    });

    return response.data;
  } catch (error) {
    functions.logger.error('字幕コンテンツ取得エラー:', error);
    return '';
  }
}

/**
 * SRT形式の字幕をプレーンテキストに変換
 * @param {string} srtContent SRT形式の字幕テキスト
 * @returns {string} 整形されたプレーンテキスト
 */
function parseSrtToText(srtContent) {
  if (!srtContent) return '';
  
  // SRTの各エントリから字幕テキストのみを抽出
  const lines = srtContent.split('\n');
  let plainText = '';
  let isTextLine = false;
  
  for (const line of lines) {
    const trimmedLine = line.trim();
    
    // 数字のみの行はスキップ（字幕番号）
    if (/^\d+$/.test(trimmedLine)) {
      continue;
    }
    
    // タイムスタンプ行はスキップ
    if (trimmedLine.includes('-->')) {
      isTextLine = true;
      continue;
    }
    
    // 空行で区切られた字幕ブロックの終わり
    if (trimmedLine === '') {
      isTextLine = false;
      continue;
    }
    
    // 字幕テキスト行を追加
    if (isTextLine) {
      plainText += trimmedLine + ' ';
    }
  }
  
  return plainText.trim();
}

/**
 * YouTube自動字幕を代替手段として取得（APIでの取得が失敗した場合）
 * @param {string} videoId YouTube動画ID
 * @returns {Promise<string>} 字幕テキスト
 */
async function fetchAutoGeneratedTranscript(videoId) {
  try {
    // 動画ページから自動生成字幕を取得するための処理
    // 注: これはYouTubeの仕様変更により動作しなくなる可能性があります
    const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const response = await axios.get(videoUrl);
    
    // 正規表現で字幕データを抽出
    const html = response.data;
    const captionRegex = /"captionTracks":\[(.*?)\]/;
    const match = html.match(captionRegex);
    
    if (!match || !match[1]) {
      return '';
    }
    
    // 字幕のJSONデータを解析
    const captionJson = JSON.parse(`{${match[1]}}`);
    if (!captionJson || !captionJson.baseUrl) {
      return '';
    }
    
    // 字幕データをダウンロード
    const captionResponse = await axios.get(captionJson.baseUrl);
    return parseSrtToText(captionResponse.data);
  } catch (error) {
    functions.logger.error('自動字幕取得エラー:', error);
    return '';
  }
}

/**
 * 音声認識APIを使用して字幕を生成（最終手段）
 * @param {string} videoId YouTube動画ID
 * @returns {Promise<string>} 生成された字幕テキスト
 */
async function generateTranscriptWithSpeechAPI(videoId) {
  try {
    // 音声ファイルをダウンロード
    const audioUrl = `https://www.youtube.com/watch?v=${videoId}`;
    
    // 以下はサードパーティ音声認識APIを使用する例
    // 実際の実装ではHugging FaceのAPIやGoogle Speech-to-TextなどのAPIを使用
    const response = await axios.post('https://api.speech-to-text-service.com/transcribe', {
      url: audioUrl,
      language: 'ja' // 言語コード
    }, {
      headers: {
        'Authorization': `Bearer ${functions.config().speech_api.key}`
      }
    });
    
    return response.data.transcript || '';
  } catch (error) {
    functions.logger.error('音声認識APIエラー:', error);
    return '';
  }
}

/**
 * 動画のトランスクリプトを取得し、Firestoreに保存する
 * @param {string} videoId YouTube動画ID
 * @returns {Promise<string>} 抽出されたトランスクリプト
 */
async function extractAndSaveTranscript(videoId) {
  try {
    // Firestoreで既存のトランスクリプトをチェック
    const transcriptDoc = await db.collection('transcripts').doc(videoId).get();
    
    if (transcriptDoc.exists) {
      // 既に処理済みの場合は保存されているデータを返す
      return transcriptDoc.data().text;
    }
    
    // 1. YouTube APIで字幕トラックを取得
    let transcript = '';
    const captionTracks = await getCaptionTracks(videoId);
    
    // 日本語字幕を優先、なければ英語、それ以外の言語の順で検索
    const jaTrack = captionTracks.find(track => track.snippet.language === 'ja');
    const enTrack = captionTracks.find(track => track.snippet.language === 'en');
    const anyTrack = captionTracks[0];
    
    const targetTrack = jaTrack || enTrack || anyTrack;
    
    if (targetTrack) {
      const captionContent = await getCaptionContent(targetTrack.id);
      transcript = parseSrtToText(captionContent);
    }
    
    // 2. APIで取得できなかった場合は自動生成字幕を試みる
    if (!transcript) {
      transcript = await fetchAutoGeneratedTranscript(videoId);
    }
    
    // 3. 最終手段として音声認識APIを使用
    if (!transcript) {
      transcript = await generateTranscriptWithSpeechAPI(videoId);
    }
    
    // トランスクリプトが取得できた場合、Firestoreに保存
    if (transcript) {
      await db.collection('transcripts').doc(videoId).set({
        videoId,
        text: transcript,
        language: targetTrack ? targetTrack.snippet.language : 'unknown',
        source: targetTrack ? 'youtube_api' : 'auto_generated',
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp()
      });
    }
    
    return transcript;
  } catch (error) {
    functions.logger.error('トランスクリプト処理エラー:', error, { videoId });
    throw new Error(`トランスクリプト抽出エラー: ${error.message}`);
  }
}

/**
 * バッチ処理で複数の動画のトランスクリプトを取得
 * @param {Array<string>} videoIds YouTube動画IDの配列
 * @returns {Promise<Object>} 動画IDとトランスクリプトのマッピング
 */
async function batchExtractTranscripts(videoIds) {
  const results = {};
  
  // API制限を考慮して逐次処理
  for (const videoId of videoIds) {
    try {
      results[videoId] = await extractAndSaveTranscript(videoId);
    } catch (error) {
      functions.logger.error(`動画 ${videoId} の処理に失敗:`, error);
      results[videoId] = null;
    }
    
    // API制限を避けるための待機
    await new Promise(resolve => setTimeout(resolve, 1000));
  }
  
  return results;
}

// Firebase Functionsとしてエクスポート
exports.extractTranscript = functions.https.onCall(async (data, context) => {
  // 認証チェック
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', '認証が必要です');
  }
  
  const { videoId } = data;
  if (!videoId) {
    throw new functions.https.HttpsError('invalid-argument', '動画IDが必要です');
  }
  
  try {
    const transcript = await extractAndSaveTranscript(videoId);
    return { success: true, transcript };
  } catch (error) {
    throw new functions.https.HttpsError('internal', error.message);
  }
});

// スケジュールされたバッチ処理
exports.scheduledTranscriptExtraction = functions.pubsub
  .schedule('every 24 hours')
  .onRun(async () => {
    try {
      // 処理が必要な動画IDを取得
      const videosSnapshot = await db.collection('videos')
        .where('transcriptProcessed', '==', false)
        .limit(50)
        .get();
      
      if (videosSnapshot.empty) {
        functions.logger.info('処理対象の動画がありません');
        return null;
      }
      
      const videoIds = videosSnapshot.docs.map(doc => doc.id);
      await batchExtractTranscripts(videoIds);
      
      // 処理済みとしてマーク
      const batch = db.batch();
      videosSnapshot.docs.forEach(doc => {
        batch.update(doc.ref, { transcriptProcessed: true });
      });
      
      await batch.commit();
      
      functions.logger.info(`${videoIds.length}件の動画トランスクリプトを処理しました`);
      return null;
    } catch (error) {
      functions.logger.error('スケジュール処理エラー:', error);
      return null;
    }
  });

// モジュールとしてエクスポート
module.exports = {
  extractAndSaveTranscript,
  batchExtractTranscripts,
  parseSrtToText
};